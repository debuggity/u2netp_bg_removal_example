<!DOCTYPE html>
<html>
  <head>
    <title>ONNX Background Removal (Respect Aspect Ratio)</title>
    <style>
      /* no fixed size on visible canvas */
      #canvas {
        display: block;
      }
    </style>
  </head>
  <body>
    <input id="image-selector" type="file" style="position:absolute; top:10px; left:10px">
    <button id="predict-button" style="position:absolute; top:10px; left:80px">Predict</button>
    <img id="selected-image" src="" style="display:none">
    <canvas id="canvas"></canvas>

    <script src="https://code.jquery.com/jquery-3.3.1.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/onnxruntime-web/dist/ort.min.js"></script>
    <script>
      $("#image-selector").change(function () {
        const reader = new FileReader();
        reader.onload = () => $("#selected-image").attr("src", reader.result);
        reader.readAsDataURL(this.files[0]);
      });

      $("#predict-button").click(async () => {
        const image = $("#selected-image")[0];
        const ow = image.naturalWidth, oh = image.naturalHeight;
        // prepare model input at 320×320
        const modelCanvas = document.createElement("canvas");
        modelCanvas.width = modelCanvas.height = 320;
        const mctx = modelCanvas.getContext("2d");
        mctx.drawImage(image, 0, 0, 320, 320);
        const imgData = mctx.getImageData(0, 0, 320, 320).data;

        // normalize & reorder to CHW
        const floatArr = new Float32Array(320 * 320 * 3);
        let ptr = 0;
        for (let i = 0; i < imgData.length; i++) {
          if ((i + 1) % 4 !== 0) floatArr[ptr++] = imgData[i] / 255;
        }
        const norm = new Float32Array(320 * 320 * 3);
        for (let i = 0; i < floatArr.length; i += 3) {
          norm[i] = (floatArr[i] - 0.485) / 0.229;
          norm[i+1] = (floatArr[i+1] - 0.456) / 0.224;
          norm[i+2] = (floatArr[i+2] - 0.406) / 0.225;
        }
        const tensorData = new Float32Array(320 * 320 * 3);
        let r=0, g=320*320, b=2*320*320;
        for (let i = 0; i < norm.length; i += 3) {
          tensorData[r++] = norm[i];
          tensorData[g++] = norm[i+1];
          tensorData[b++] = norm[i+2];
        }
        const session = await ort.InferenceSession.create("./u2netp.onnx");
        const inputTensor = new ort.Tensor("float32", tensorData, [1,3,320,320]);
        const feeds = { [session.inputNames[0]]: inputTensor };
        const pred = (await session.run(feeds))[session.outputNames[0]].data;

        // build mask canvas (320×320 grayscale)
        const maskCanvas = document.createElement("canvas");
        maskCanvas.width = maskCanvas.height = 320;
        const maskCtx = maskCanvas.getContext("2d");
        const maskImg = maskCtx.createImageData(320, 320);
        for (let i = 0; i < pred.length; i++) {
          const pi = i * 4;
          const v = Math.round(pred[i] * 255);
          maskImg.data[pi] = maskImg.data[pi+1] = maskImg.data[pi+2] = v;
          maskImg.data[pi+3] = v;
        }
        maskCtx.putImageData(maskImg, 0, 0);

        // draw original + apply mask on visible canvas at original size
        const canvas = document.getElementById("canvas");
        canvas.width = ow; canvas.height = oh;
        const ctx = canvas.getContext("2d");
        ctx.clearRect(0, 0, ow, oh);
        ctx.drawImage(image, 0, 0, ow, oh);
        ctx.globalCompositeOperation = "destination-in";
        ctx.drawImage(maskCanvas, 0, 0, ow, oh);
        ctx.globalCompositeOperation = "source-over";
      });
    </script>
  </body>
</html>
