<!DOCTYPE html>
<html>
  <head>
    <title>ONNX Runtime JavaScript – Background Removal</title>
    <style>
      /* ensure canvas is exactly the image size */
      #canvas {
        width: 320px;
        height: 320px;
      }
    </style>
  </head>
  <body>
    <input id="image-selector" type="file" style="position:absolute; top:10px; left:10px">
    <button id="predict-button" style="position:absolute; top:10px; left:80px">Predict</button>
    <img id="selected-image" src="" style="display:none">
    <canvas id="canvas" width="320" height="320"></canvas>

    <script src="https://code.jquery.com/jquery-3.3.1.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/onnxruntime-web/dist/ort.min.js"></script>
    <script>
      $("#image-selector").change(function () {
        const reader = new FileReader();
        reader.onload = function () {
          $("#selected-image").attr("src", reader.result);
        };
        reader.readAsDataURL($("#image-selector").prop("files")[0]);
      });

      $("#predict-button").click(async function () {
        const canvas = document.getElementById("canvas");
        const ctx = canvas.getContext("2d");
        const image = $("#selected-image").get(0);

        // Draw the chosen image into a hidden offscreen canvas at 320×320
        const oc = document.createElement("canvas");
        const octx = oc.getContext("2d");
        oc.width = 320;
        oc.height = 320;
        octx.drawImage(image, 0, 0, 320, 320);
        const input_imageData = octx.getImageData(0, 0, 320, 320);

        // Load U2NetP ONNX model
        const session = await ort.InferenceSession.create("./u2netp.onnx");

        // Prepare float32 tensor from the resized image
        const raw = input_imageData.data;
        const floatArr = new Float32Array(320 * 320 * 3);
        let j = 0;
        for (let i = 0; i < raw.length; i++) {
          if ((i + 1) % 4 !== 0) {
            floatArr[j++] = raw[i] / 255;
          }
        }

        // Normalize (RGB) and reorder to [1, 3, 320, 320]
        const norm = new Float32Array(320 * 320 * 3);
        for (let i = 0; i < floatArr.length; i += 3) {
          norm[i] = (floatArr[i] - 0.485) / 0.229;
          norm[i + 1] = (floatArr[i + 1] - 0.456) / 0.224;
          norm[i + 2] = (floatArr[i + 2] - 0.406) / 0.225;
        }
        const tensorData = new Float32Array(320 * 320 * 3);
        // reorder HWC → CHW
        let idxR = 0, idxG = 320 * 320, idxB = 2 * 320 * 320;
        for (let i = 0; i < norm.length; i += 3) {
          tensorData[idxR++] = norm[i];
          tensorData[idxG++] = norm[i + 1];
          tensorData[idxB++] = norm[i + 2];
        }

        const inputTensor = new ort.Tensor("float32", tensorData, [1, 3, 320, 320]);
        const feeds = { [session.inputNames[0]]: inputTensor };
        const results = await session.run(feeds);
        const pred = Object.values(results)[0]; // Float32Array of length 102400

        // Build a new ImageData where alpha = mask * 255, and RGB from original
        const outImage = ctx.createImageData(320, 320);
        for (let i = 0; i < pred.data.length; i++) {
          const px = i * 4;
          // copy original RGB
          outImage.data[px] = input_imageData.data[px];
          outImage.data[px + 1] = input_imageData.data[px + 1];
          outImage.data[px + 2] = input_imageData.data[px + 2];
          // set alpha channel based on mask value (0–1)
          outImage.data[px + 3] = Math.round(pred.data[i] * 255);
        }

        // Clear and draw at (0,0) to fill the entire canvas
        ctx.clearRect(0, 0, 320, 320);
        ctx.putImageData(outImage, 0, 0);
      });
    </script>
  </body>
</html>
